# -*- coding: utf-8 -*-
"""
Created on Mon Feb  6 10:49:59 2023

@author: jacob
"""
import os
from copy import deepcopy
import numpy as np
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
import contextily as cx
from sklearn.metrics import mean_absolute_error

# Set paths to GDAL in virtual env to avoid proj.db errors
os.environ['PROJ_LIB'] = r"C:\Users\jacob\.conda\envs\yield\Library\share\proj"
os.environ['GDAL_DATA'] = r"C:\Users\jacob\.conda\envs\yield\Library\share"

def myround(x, base=5):
    return base * round(int(x)/base)

def interval_coverage(obs, mean, stdev, level = 0.95):
    import numpy as np
    from scipy.stats import norm
    obs = obs.squeeze()
    z = norm.ppf((1 + level) / 2)
    lower_bound = mean - stdev * z
    upper_bound = mean + stdev * z
    num_within_intervals = np.sum((obs >= lower_bound) & (obs <= upper_bound))
    coverage = num_within_intervals / len(obs) * 100
    return(round(coverage, 1))

# Get accuracy metrics for each TWP, then join to SHP
def calculate_mae(group):
    return mean_absolute_error(group['TotalYield'], group['PredMean'])

def calculate_ic(group):
    import numpy as np
    ic = interval_coverage(group['TotalYield'], group['PredMean'], group['PredStd'], level = 0.95)
    #return (ic)
    return(np.abs(ic - 95))

def create_new_labels(current_labels, type = "roundfive"):
    no_labels = len(current_labels)
    new_labels = []
    for ix, val in enumerate(current_labels):
        if type == "roundfive":
            val0 = str(myround(int(float(val.split(',')[0]))))
            val1 = str(myround(int(float(val.split(',')[1]))))
        else:
            val0 = str(int(float(val.split(',')[0])))
            val1 = str(int(float(val.split(',')[1])))
        if ix == 0:  # first item
            val0 = str(int(float(val.split(',')[0])))
            val = '<' + val1
        elif no_labels == ix + 1:  # last item
            val = '>' + val0
        else:  # remaining items
            val = val0 + ' - ' + val1
            #val = val.replace(',', ' -')
        new_labels.append((ix,val))
    new_labels = dict(new_labels)
    return (new_labels)

def create_new_labels2(current_labels, type = "roundfive"):
    no_labels = len(current_labels)
    new_labels = []
    for ix, val in enumerate(current_labels):
        if type == "roundfive":
            val0 = str(myround(int(float(val.split(', ')[0]))))
            val1 = str(myround(int(float(val.split(', ')[1]))))
        else:
            val0 = str(int(float(val.split(', ')[0])))
            val1 = str(int(float(val.split(', ')[1])))
        # if ix == 0:  # first item
        #     val0 = str(int(float(val.split(',')[0])))
        #     val = '<' + val1
        # elif no_labels == ix + 1:  # last item
        #     val = '>' + val0
        # else:  # remaining items
        val = val0 + ' - ' + val1
            #val = val.replace(',', ' -')
        new_labels.append((ix,val))
    new_labels = dict(new_labels)
    return (new_labels)

def update_custom_legend_labels(ax, new_labels):
    current_legend = ax.get_legend()
    for ix_current_label, txt_current_label in enumerate(current_legend.get_texts()):
        for ix_new_label, txt_new_label in new_labels.items():
            if ix_current_label == ix_new_label:
                # print(f'current: {ix_current_label, txt_current_label}')
                # print(f'new: {ix_new_label, txt_new_label}')
                txt_current_label.set_text(txt_new_label)
                # print(f'update: {txt_current_label}')

# Analyze results of mean NDVI
def get_weekly_results(df, changeweeks, ndvi_level = 'Mean'):
    from copy import deepcopy
    from scipy.stats import ttest_ind
    for week in changeweeks:
        df_w = df[(df['Week'] == week) & (df['Ndvi_Levels'] == ndvi_level)]
        df_results = pd.DataFrame(data = {'NDMeanYield': [df_w[(df_w['ModeCDM'] == 0) & (df_w['ModeCDM-1'] == 0)].loc[:,'MeanYieldPred'].mean()]})
        df_results['NDStdYield'] = df_w[(df_w['ModeCDM'] == 0) & (df_w['ModeCDM-1'] == 0)].loc[:,'StdYieldPred'].mean()
        df_results['D0MeanYield'] = df_w[(df_w['ModeCDM'] == 1) & (df_w['ModeCDM-1'] == 1)].loc[:,'MeanYieldPred'].mean()
        df_results['D0StdYield'] = df_w[(df_w['ModeCDM'] == 1) & (df_w['ModeCDM-1'] == 1)].loc[:,'StdYieldPred'].mean()
        df_results['D1MeanYield'] = df_w[(df_w['ModeCDM'] == 2) & (df_w['ModeCDM-1'] == 2)].loc[:,'MeanYieldPred'].mean()
        df_results['D1StdYield'] = df_w[(df_w['ModeCDM'] == 2) & (df_w['ModeCDM-1'] == 2)].loc[:,'StdYieldPred'].mean()
        df_results['D2MeanYield'] = df_w[(df_w['ModeCDM'] == 3) & (df_w['ModeCDM-1'] == 3)].loc[:,'MeanYieldPred'].mean()
        df_results['D2StdYield'] = df_w[(df_w['ModeCDM'] == 3) & (df_w['ModeCDM-1'] == 3)].loc[:,'StdYieldPred'].mean()
        df_results['D3MeanYield'] = df_w[(df_w['ModeCDM'] == 4) & (df_w['ModeCDM-1'] == 4)].loc[:,'MeanYieldPred'].mean()
        df_results['D3StdYield'] = df_w[(df_w['ModeCDM'] == 4) & (df_w['ModeCDM-1'] == 4)].loc[:,'StdYieldPred'].mean()
        df_results['D4MeanYield'] = df_w[(df_w['ModeCDM'] == 5) & (df_w['ModeCDM-1'] == 5)].loc[:,'MeanYieldPred'].mean()
        df_results['D4StdYield'] = df_w[(df_w['ModeCDM'] == 5) & (df_w['ModeCDM-1'] == 5)].loc[:,'StdYieldPred'].mean()
        df_results['D0OnsetMeanYield'] = df_w[(df_w['ModeCDM'] == 1) & (df_w['ModeCDM-1'] == 0)].loc[:, 'MeanYieldPred'].mean()
        df_results['D0OnsetStdYield'] = df_w[(df_w['ModeCDM'] == 1) & (df_w['ModeCDM-1'] == 0)].loc[:, 'StdYieldPred'].mean()
        df_results['D1OnsetMeanYield'] = df_w[(df_w['ModeCDM'] == 2) & (df_w['ModeCDM-1'] == 1)].loc[:, 'MeanYieldPred'].mean()
        df_results['D1OnsetStdYield'] = df_w[(df_w['ModeCDM'] == 2) & (df_w['ModeCDM-1'] == 1)].loc[:, 'StdYieldPred'].mean()
        df_results['D2OnsetMeanYield'] = df_w[(df_w['ModeCDM'] == 3) & (df_w['ModeCDM-1'] == 2)].loc[:, 'MeanYieldPred'].mean()
        df_results['D2OnsetStdYield'] = df_w[(df_w['ModeCDM'] == 3) & (df_w['ModeCDM-1'] == 2)].loc[:, 'StdYieldPred'].mean()
        df_results['D3OnsetMeanYield'] = df_w[(df_w['ModeCDM'] == 4) & (df_w['ModeCDM-1'] == 3)].loc[:, 'MeanYieldPred'].mean()
        df_results['D3OnsetStdYield'] = df_w[(df_w['ModeCDM'] == 4) & (df_w['ModeCDM-1'] == 3)].loc[:, 'StdYieldPred'].mean()
        df_results['D4OnsetMeanYield'] = df_w[(df_w['ModeCDM'] == 5) & (df_w['ModeCDM-1'] == 4)].loc[:, 'MeanYieldPred'].mean()
        df_results['D4OnsetStdYield'] = df_w[(df_w['ModeCDM'] == 5) & (df_w['ModeCDM-1'] == 4)].loc[:, 'StdYieldPred'].mean()
        df_results['Week'] = week

        # Get significance of results compared to historical yields
        #df_w_yield = df_yield[(df_yield['Week'] == week)]
        nd = df_w[(df_w['ModeCDM'] == 0) & (df_w['ModeCDM-1'] == 0)].loc[:,'MeanYieldPred']
        d0 = df_w[(df_w['ModeCDM'] == 1) & (df_w['ModeCDM-1'] == 0)].loc[:,'MeanYieldPred']
        d1 = df_w[(df_w['ModeCDM'] == 2) & (df_w['ModeCDM-1'] == 1)].loc[:,'MeanYieldPred']
        d2 = df_w[(df_w['ModeCDM'] == 3) & (df_w['ModeCDM-1'] == 2)].loc[:,'MeanYieldPred']
        d3 = df_w[(df_w['ModeCDM'] == 4) & (df_w['ModeCDM-1'] == 3)].loc[:,'MeanYieldPred']
        d4 = df_w[(df_w['ModeCDM'] == 5) & (df_w['ModeCDM-1'] == 4)].loc[:,'MeanYieldPred']
        nd_t, nd_p = ttest_ind(a=nd, b=d0, equal_var=False) # Welch's (not equal var)
        d0_t, d0_p = ttest_ind(a=nd, b=d0, equal_var=False) # Welch's (not equal var)
        d1_t, d1_p = ttest_ind(a=nd, b=d1, equal_var=False) # Welch's (not equal var)
        d2_t, d2_p = ttest_ind(a=nd, b=d2, equal_var=False) # Welch's (not equal var)
        d3_t, d3_p = ttest_ind(a=nd, b=d3, equal_var=False) # Welch's (not equal var)
        d4_t, d4_p = ttest_ind(a=nd, b=d4, equal_var=False) # Welch's (not equal var)
        df_sig = pd.DataFrame(data = {'D0_Sig': [d0_p]})
        df_sig['D1_Sig'] = d1_p
        df_sig['D2_Sig'] = d2_p
        df_sig['D3_Sig'] = d3_p
        df_sig['D4_Sig'] = d4_p
        df_sig['Week'] = week

        if week == changeweeks[0]:
            df_final = deepcopy(df_results)
            df_sig_final = deepcopy(df_sig)
        else:
            df_final = pd.concat([df_final, df_results])
            df_sig_final = pd.concat([df_sig_final, df_sig])
    df_final = df_final.set_index('Week')
    df_sig_final = df_sig_final.set_index('Week')
    return (df_final, df_sig_final)

def plot_weekly_results(df_results, df, synthBarDir, ndvi_level = 'Mean'):
    #figure, axis = plt.subplots(2, 2)
    width = 0.15
    x = np.arange(5)
    nd_mean = df_results.loc[:,'NDMeanYield'].values[0]
    nd_upper = nd_mean + df_results.loc[:,'NDStdYield'].values[0]
    nd_lower = nd_mean - df_results.loc[:,'NDStdYield'].values[0]
    #nd_mean = df[(df['ModeCDM'] == 0) & (df['ModeCDM-1'] == 0) & (df['ModeCDM-2'] == 0) & (df['ModeCDM-3'] == 0) & (df['ModeCDM-4'] == 0) & (df['Ndvi_Levels'] == ndvi_level)].loc[:,'MeanYieldPred'].values.mean()
    #nd_upper = nd_mean + df[(df['ModeCDM'] == 0) & (df['ModeCDM-1'] == 0) & (df['ModeCDM-2'] == 0) & (df['ModeCDM-3'] == 0) & (df['ModeCDM-4'] == 0)].loc[:,'StdYieldPred'].values.mean()
    #nd_lower = nd_mean - df[(df['ModeCDM'] == 0) & (df['ModeCDM-1'] == 0) & (df['ModeCDM-2'] == 0) & (df['ModeCDM-3'] == 0) & (df['ModeCDM-4'] == 0)].loc[:,'StdYieldPred'].values.mean()
    D0mean = df_results.loc[:,'D0OnsetMeanYield'].values
    D0std = df_results.loc[:,'D0OnsetStdYield'].values
    D1mean = df_results.loc[:,'D1OnsetMeanYield'].values
    D1std = df_results.loc[:,'D1OnsetStdYield'].values
    D2mean = df_results.loc[:,'D2OnsetMeanYield'].values
    D2std = df_results.loc[:,'D2OnsetStdYield'].values
    D3mean = df_results.loc[:,'D3OnsetMeanYield'].values
    D3std = df_results.loc[:,'D3OnsetStdYield'].values
    D4mean = df_results.loc[:,'D4OnsetMeanYield'].values
    D4std = df_results.loc[:,'D4OnsetStdYield'].values

    # Create the figure and axis objects
    fig, ax = plt.subplots(layout='constrained')
    # Bars
    ax.bar(x + width*0, D0mean, width, label='D0 Onset', color='#FFEA46FF')
    ax.bar(x + width*1, D1mean, width, label='D1 Onset', color='#BCAF6FFF')
    ax.bar(x + width*2, D2mean, width, label='D2 Onset', color='#7C7B78FF')
    ax.bar(x + width*3, D3mean, width, label='D3 Onset', color='#414D6BFF')
    ax.bar(x + width*4, D4mean, width, label='D4 Onset', color='#00204DFF')
    e1 = ax.errorbar(x + width*0, D0mean, yerr=D0std, fmt='none', color='red')
    e1[-1][0].set_linestyle('--')
    e2 = ax.errorbar(x + width*1, D1mean, yerr=D1std, fmt='none', color='red')
    e2[-1][0].set_linestyle('--')
    e3 = ax.errorbar(x + width*2, D2mean, yerr=D2std, fmt='none', color='red')
    e3[-1][0].set_linestyle('--')
    e4 = ax.errorbar(x + width*3, D3mean, yerr=D3std, fmt='none', color='red')
    e4[-1][0].set_linestyle('--')
    e5 = ax.errorbar(x + width*4, D4mean, yerr=D4std, fmt='none', color='red')
    e5[-1][0].set_linestyle('--')

    # Add asterisks above the bars
    # for i in list(range(0, 5)):
    #     x_coord = x + width*i
    #     if i == 0:
    #         values = D0mean
    #     elif i == 1:
    #         values = D1mean
    #     elif i == 2:
    #         values = D2mean
    #     elif i == 3:
    #         values = D3mean
    #     elif i == 4:
    #         values = D4mean
    #     for a, b in zip(x_coord, values):
    #         t_statistic, p_value = ttest_ind(
    #             a=df.loc[:,'NDMeanYield'].values[0],
    #             b=np.random.normal(loc=mean_group2, scale=std_group2, size=sample_size_group2),
    #             equal_var=True  # Set to False if the assumption of equal variances is violated
    #         )
    #         plt.text(a, b, "*", ha='center', va='bottom', fontweight='bold', fontsize=12)

    # ND lines
    ax.axhline(y=nd_mean, color='black', linestyle='--', label='No Drought')
    ax.axhline(y=nd_upper, color='red', linestyle='--', label='95% CI')
    ax.axhline(y=nd_lower, color='red', linestyle='--')

    # Set labels and title
    ax.set_xlabel('Month')
    ax.set_ylabel('Predicted Yield (kg/ha)')
    ax.set_xticks(x + width*2)
    ax.set_xticklabels(['May', 'June', 'July', 'August'])
    ax.set_ylim(0, 2400)
    # Legend details
    box = ax.get_position()
    ax.set_position([box.x0, box.y0 + box.height * 0.2,
                     box.width, box.height * 0.9])
    # Put a legend below current axis
    ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),
              fancybox=True, ncol=4)
    plt.savefig(synthBarDir + f'\\Synthetic_Barplot_{ndvi_level}.png', bbox_inches='tight', dpi=1200)
    plt.show()

def plot_all_weekly_results(mean_results, minus_results, plus_results, synthBarDir):
    # Create the figure and axes objects
    fig, ax = plt.subplots(2, 2, figsize=(10, 8))
    i = 0
    for results in [mean_results, minus_results, plus_results]:
        if i == 0:
            coord0 = 0
            coord1 = 0
            ndvi_level = 'Mean'
        elif i == 1:
            coord0 = 0
            coord1 = 1
            ndvi_level = '-1SD'
        else:
            coord0 = 1
            coord1 = 0
            ndvi_level = '+1SD'
        width = 0.15
        x = np.arange(5)
        nd_mean = results.loc[:, 'NDMeanYield'].values[0]
        nd_upper = nd_mean + results.loc[:, 'NDStdYield'].values[0]
        nd_lower = nd_mean - results.loc[:, 'NDStdYield'].values[0]
        D0mean = results.loc[:, 'D0OnsetMeanYield'].values
        D0std = results.loc[:, 'D0OnsetStdYield'].values
        D1mean = results.loc[:, 'D1OnsetMeanYield'].values
        D1std = results.loc[:, 'D1OnsetStdYield'].values
        D2mean = results.loc[:, 'D2OnsetMeanYield'].values
        D2std = results.loc[:, 'D2OnsetStdYield'].values
        D3mean = results.loc[:, 'D3OnsetMeanYield'].values
        D3std = results.loc[:, 'D3OnsetStdYield'].values
        D4mean = results.loc[:, 'D4OnsetMeanYield'].values
        D4std = results.loc[:, 'D4OnsetStdYield'].values
        # Bars
        ax[coord0,coord1].bar(x + width * 0, D0mean, width, label='D0 Onset', color='#FFEA46FF')
        ax[coord0,coord1].bar(x + width * 1, D1mean, width, label='D1 Onset', color='#BCAF6FFF')
        ax[coord0,coord1].bar(x + width * 2, D2mean, width, label='D2 Onset', color='#7C7B78FF')
        ax[coord0,coord1].bar(x + width * 3, D3mean, width, label='D3 Onset', color='#414D6BFF')
        ax[coord0,coord1].bar(x + width * 4, D4mean, width, label='D4 Onset', color='#00204DFF')
        e1 = ax[coord0,coord1].errorbar(x + width * 0, D0mean, yerr=D0std, fmt='none', color='red')
        e1[-1][0].set_linestyle('--')
        e2 = ax[coord0,coord1].errorbar(x + width * 1, D1mean, yerr=D1std, fmt='none', color='red')
        e2[-1][0].set_linestyle('--')
        e3 = ax[coord0,coord1].errorbar(x + width * 2, D2mean, yerr=D2std, fmt='none', color='red')
        e3[-1][0].set_linestyle('--')
        e4 = ax[coord0,coord1].errorbar(x + width * 3, D3mean, yerr=D3std, fmt='none', color='red')
        e4[-1][0].set_linestyle('--')
        e5 = ax[coord0,coord1].errorbar(x + width * 4, D4mean, yerr=D4std, fmt='none', color='red')
        e5[-1][0].set_linestyle('--')

        # ND lines
        ax[coord0, coord1].axhline(y=nd_mean, color='black', linestyle='--', label='No Drought')
        ax[coord0, coord1].axhline(y=nd_upper, color='red', linestyle='--', label='95% CI')
        ax[coord0, coord1].axhline(y=nd_lower, color='red', linestyle='--')

        # Set labels and title
        ax[coord0, coord1].set_title(ndvi_level)
        ax[coord0, coord1].set_xlabel('Month')
        ax[coord0, coord1].set_ylabel('Predicted Yield (kg/ha')
        ax[coord0, coord1].set_xticks(x + width * 2)
        ax[coord0, coord1].set_xticklabels(['May', 'June', 'July', 'August'])
        ax[coord0, coord1].set_ylim(0, 1850)
        # Legend details
        box = ax[coord0, coord1].get_position()
        ax[coord0, coord1].set_position([box.x0, box.y0 + box.height * 0.2,
                         box.width, box.height * 0.9])
        if i == 2:
            handles, labels = ax[coord0, coord1].get_legend_handles_labels()
        i +=1
    # Remove the empty subplot in the fourth quadrant
    fig.delaxes(ax[1, 1])
    # Add a legend
    ax_legend = fig.add_subplot(2, 2, 4)
    ax_legend.axis('off')
    legend = fig.legend(handles, labels, loc=(0.67, 0.1))
    legend.get_frame().set_facecolor('none')  # Make the legend background transparent
    for text in legend.get_texts():
        text.set_fontsize(18)
    # Adjust the layout
    fig.tight_layout()
    plt.autoscale()
    # Show the plot
    plt.show()

def onset_figures(df, boxDir, mapDir, ndvi_level = 'Mean'):
    import os
    import numpy as np
    import seaborn as sns
    import mapclassify as mc
    import matplotlib.colors as mcolors
    from matplotlib.colors import TwoSlopeNorm
    import warnings
    warnings.filterwarnings("ignore")
    np.set_printoptions(suppress=True)

    ########################################## Grouped Boxplot #######################################
    vars = ["MeanPctYieldDiff", 'StdPctYieldDiff']
    df_onset = df[(df['Ndvi_Levels'] == ndvi_level)]
    df_onset.loc[:,'MeanPctYieldDiff'] = ((df_onset.loc[:,'MeanYieldPred'] - df_onset.loc[:,'MeanTotalYield']) / df_onset.loc[:,'MeanTotalYield'])*100
    df_onset.loc[:, 'StdPctYieldDiff'] = (((df_onset.loc[:,'StdYieldPred']) / df_onset.loc[:,'MeanTotalYield'])*100)*1.96 # 95% CI
    for var in vars:
        stat = 'Stdev' if var[0:3] == 'Std' else 'Mean'
        # Mean Yield Diff Boxplots as a % of Mean Yield for each week
        custom_palette = ['grey', '#fac228', '#f57d15', '#d44842', '#9f2a63', '#65156e', '#280b53']
        for timescale in ['Week', 'Month']:
            outDir = boxDir + f'//NDVI{ndvi_level}' + f'//{timescale}'
            os.makedirs(outDir, exist_ok=True)
            outfile = outDir + f'//Boxplot_PctChangein{stat}Yield_NDVI{ndvi_level}_{timescale}.png'
            if not os.path.exists(outfile):
                plt.figure(figsize=(10, 6))
                sns.set_palette(custom_palette)
                boxplot = sns.boxplot(x=timescale, y=var, hue="ModeCDM", data=df_onset, showfliers=False)
                if stat == 'Mean':
                    boxplot.axhline(y=0, color='r', linestyle='--')  # add zero line
                boxplot.set_xlabel(timescale)
                if stat == 'Mean':
                    boxplot.set_ylabel(f'Predicted Yield Anomaly (% of Mean Yield)')
                else:
                    boxplot.set_ylabel(f'Predicted Uncertainty (% of Mean Yield) at 95% CI')
                if timescale == 'Month':
                    boxplot.set_xticklabels(['May', 'June', 'July', 'August', 'September'])
                # Legend details
                legend = boxplot.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),
                                        fancybox=True, ncol=3)
                new_labels = ['ND', 'D0', 'D1', 'D2', 'D3', 'D4']
                for t, l in zip(legend.texts, new_labels):
                    t.set_text(l)
                plt.subplots_adjust(bottom = 0.2)
                sns.set_palette(custom_palette)
                # Export
                plt.savefig(outfile, bbox_inches='tight', dpi=1200)
                plt.show()

    ################################### MAPPING ################################
    custom_seq_palette = ['#fac228', '#f57d15', '#d44842', '#9f2a63', '#65156e', '#280b53']
    for cat in list(range(0, 6)):
        df_cat = df_onset[df_onset['ModeCDM'] == cat].reset_index(drop=True)
        for timescale in ['Week', 'Month']:
            periods = df_cat[timescale].unique()
            for period in periods:
                df_period = df_cat[df_cat[timescale] == period].reset_index(drop=True)
                for var in vars:
                    outDir = mapDir + f'//NDVI{ndvi_level}' + f'//{timescale}'
                    os.makedirs(outDir, exist_ok=True)
                    outfile = outDir + f'//{var}_Cat{cat}_{timescale}{period}_NDVI{ndvi_level}.png'
                    if not os.path.exists(outfile):
                        stat = 'Stdev' if var[0:3] == 'Std' else 'Mean'
                        # Get TWP SHP and sort dfs by TWP:
                        twp_shp = gpd.read_file(r"D:\PhD\YieldProject\Data\Yield\WheatYield_Township.shp")
                        twp_shp = twp_shp[['TWP_ID', 'geometry']]
                        twp_shp = twp_shp[twp_shp['TWP_ID'].isin(df_cat['TWP_ID'])]
                        twp_shp.reset_index(drop=True, inplace=True)
                        twp_shp = twp_shp.merge(df_period, on='TWP_ID')
                        # Classification
                        total_bins = 6  # Must be even num
                        if stat == 'Mean':
                            pos_values = twp_shp.loc[twp_shp[var] > 0, var]
                            neg_values = twp_shp.loc[twp_shp[var] < 0, var]
                            neg_binnum = round(total_bins * (len(neg_values) / len(twp_shp[var])))
                            pos_binnum = total_bins - neg_binnum
                            if neg_binnum == total_bins:
                                neg_classifier = mc.Quantiles(neg_values, k=neg_binnum)
                                neg_bins = neg_classifier.bins
                                bins = [neg_values.min()] + list(neg_bins)
                                bins[bins.index(max(n for n in bins if n < 0))] = 0  # Ensure zero values
                                twp_shp['classifications'] = pd.Series(neg_classifier.yb) #, index=neg_values.index
                                twp_shp['classifications'] = twp_shp['classifications'].fillna(twp_shp['classifications'].max())
                                low = plt.get_cmap('BrBG')(0)
                                mid = plt.get_cmap('BrBG')(0.2)
                                high = plt.get_cmap('BrBG')(0.4)
                                cmap = mcolors.LinearSegmentedColormap.from_list("custom", [(0, low), (0.5, mid), (1, high)])
                            elif pos_binnum == total_bins:
                                pos_classifier = mc.Quantiles(pos_values, k=pos_binnum)
                                pos_bins = pos_classifier.bins
                                bins = [0] + list(pos_bins)
                                twp_shp['classifications'] = pd.Series(pos_classifier.yb)
                                twp_shp['classifications'] = twp_shp['classifications'].fillna(twp_shp['classifications'].min())
                                low = plt.get_cmap('BrBG')(0.6)
                                mid = plt.get_cmap('BrBG')(0.75)
                                high = plt.get_cmap('BrBG')(0.9)
                                cmap = mcolors.LinearSegmentedColormap.from_list("custom", [(0, low), (0.5, mid), (1, high)])
                            else:
                                neg_classifier = mc.Quantiles(neg_values, k=neg_binnum)
                                pos_classifier = mc.Quantiles(pos_values, k=pos_binnum)
                                pos_bins = pos_classifier.bins
                                neg_bins = neg_classifier.bins
                                bins = [neg_values.min()] + list(neg_bins) + list(pos_bins)
                                bins[bins.index(max(n for n in bins if n < 0))] = 0 # Ensure zero values
                                nyb = pd.Series(neg_classifier.yb, index=neg_values.index) + pos_binnum
                                twp_shp['classifications'] = pd.concat([pd.Series(pos_classifier.yb, index=pos_values.index), nyb])
                                # Define the colors, in this case we are using colors from the BrBG color maps.
                                low = plt.get_cmap('BrBG')(0)
                                mid1 = plt.get_cmap('BrBG')(0.4)
                                mid2 = plt.get_cmap('BrBG')(0.6)
                                high = plt.get_cmap('BrBG')(0.9)
                                cmap = mcolors.LinearSegmentedColormap.from_list("custom", [(0, low), (0.499, mid1), (0.501, mid2), (1, high)])
                                norm = TwoSlopeNorm(vmin=0, vcenter=bins.index(0), vmax=len(bins) - 1) # Colorramp for pos and neg
                            new_labels = []
                            for i in range(0, len(bins)-1):
                                new_labels.append(str(round(bins[i], 2)) + ' to ' + str(round(bins[i+1], 2)))
                        else:
                            classifier = mc.Quantiles(twp_shp[var], k=total_bins)
                            twp_shp['classifications'] = pd.Series(classifier.yb)
                            bins = [twp_shp[var].min()] + list(classifier.bins)
                            cmap = mcolors.ListedColormap(custom_seq_palette)
                        new_labels = []
                        for i in range(0, len(bins) - 1):
                            if i == 0 or i == len(bins) - 2:
                                Q1 = twp_shp[var].quantile(0.25)
                                Q3 = twp_shp[var].quantile(0.75)
                                IQR = Q3 - Q1
                                if i == 0:
                                    lower_bound = Q1 - 1.5 * IQR
                                    new_labels.append(
                                        str(round(max(lower_bound, bins[i]), 2)) + ' to ' + str(round(bins[i + 1], 2)))
                                else:
                                    upper_bound = Q3 + 1.5 * IQR
                                    new_labels.append(str(round(bins[i], 2)) + ' to ' + str(
                                        round(min(upper_bound, bins[len(bins) - 1]), 2)))
                            else:
                                new_labels.append(str(round(bins[i], 2)) + ' to ' + str(round(bins[i + 1], 2)))
                        xmin, ymin, xmax, ymax = twp_shp.total_bounds
                        fig, ax = plt.subplots(figsize=(9, 7))
                        if (stat == 'Mean') & (pos_binnum != total_bins) & (neg_binnum != total_bins):
                            twp_shp.plot(column='classifications', categorical=True, legend=True, cmap=cmap, norm=norm, ax=ax,
                                         legend_kwds = {"loc": "best", "labels": new_labels})
                        else:
                            twp_shp.plot(column='classifications', categorical=True, legend=True, cmap=cmap, ax=ax,
                                         legend_kwds = {"loc": "best", "labels": new_labels})
                        cx.add_basemap(ax, source=cx.providers.Stamen.TonerLite, crs=twp_shp.crs.to_string(), attribution_size=0)
                        # Create spacing from data to map frame
                        ax.set_xlim(xmin - 30000, xmax + 30000)
                        ax.set_ylim(ymin - 20000, ymax + 20000)
                        ax.set_xlabel('Longitude')
                        ax.set_ylabel('Latitude')
                        # Set custom tick positions and labels for the x-axis
                        xtick_positions = [-1.4, -1.2, -1.0, -0.8, -0.6, -0.4, -0.2]
                        xtick_positions = [x * 1e6 for x in xtick_positions]
                        xtick_labels = ['115°W', '112°W', '109°W', '106°W', '103°W', '100°W', '97°W']
                        plt.xticks(xtick_positions, xtick_labels)
                        ytick_positions = [2.20, 1.96, 1.72, 1.48, 1.24, 1.0]
                        ytick_positions = [x * 1e6 for x in ytick_positions]
                        ytick_labels = ['59°N', '57°N', '55°N', '53°N', '51°N', '49°N']
                        plt.yticks(ytick_positions, ytick_labels)
                        # Export
                        plt.savefig(outfile, bbox_inches='tight', dpi=1200)
                        plt.show()

def create_synthetic_maps(df, changeweeks, synthMapDir, ndvi_level = 'Mean'):
    import os
    for week in changeweeks:
        df_w = df[(df['Week'] == week) & (df['Ndvi_Levels'] == ndvi_level)]
        print(len(df_w))
        df_results = pd.DataFrame(data = {'TWP_ID': df_w['TWP_ID'].unique()})
        print (len(df_results))
        df_results['NDMeanYield'] = df_w[(df_w['ModeCDM'] == 0) & (df_w['ModeCDM-1'] == 0)].loc[:,'MeanYieldPred'].values
        df_results['NDStdYield'] = df_w[(df_w['ModeCDM'] == 0) & (df_w['ModeCDM-1'] == 0)].loc[:,'StdYieldPred'].values
        df_results['D0OnsetMeanYieldDiff'] = df_w[(df_w['ModeCDM'] == 1) & (df_w['ModeCDM-1'] == 0)].loc[:, 'MeanYieldPred'].values - df_results['NDMeanYield'].values
        df_results['D0OnsetStdYieldDiff'] = df_w[(df_w['ModeCDM'] == 1) & (df_w['ModeCDM-1'] == 0)].loc[:, 'StdYieldPred'].values - df_results['NDStdYield'].values
        df_results['D1OnsetMeanYieldDiff'] = df_w[(df_w['ModeCDM'] == 2) & (df_w['ModeCDM-1'] == 1)].loc[:, 'MeanYieldPred'].values - df_results['NDMeanYield'].values
        df_results['D1OnsetStdYieldDiff'] = df_w[(df_w['ModeCDM'] == 2) & (df_w['ModeCDM-1'] == 1)].loc[:, 'StdYieldPred'].values - df_results['NDStdYield'].values
        df_results['D2OnsetMeanYieldDiff'] = df_w[(df_w['ModeCDM'] == 3) & (df_w['ModeCDM-1'] == 2)].loc[:, 'MeanYieldPred'].values - df_results['NDMeanYield'].values
        df_results['D2OnsetStdYieldDiff'] = df_w[(df_w['ModeCDM'] == 3) & (df_w['ModeCDM-1'] == 2)].loc[:, 'StdYieldPred'].values - df_results['NDStdYield'].values
        df_results['D3OnsetMeanYieldDiff'] = df_w[(df_w['ModeCDM'] == 4) & (df_w['ModeCDM-1'] == 3)].loc[:, 'MeanYieldPred'].values - df_results['NDMeanYield'].values
        df_results['D3OnsetStdYieldDiff'] = df_w[(df_w['ModeCDM'] == 4) & (df_w['ModeCDM-1'] == 3)].loc[:, 'StdYieldPred'].values - df_results['NDStdYield'].values
        df_results['D4OnsetMeanYieldDiff'] = df_w[(df_w['ModeCDM'] == 5) & (df_w['ModeCDM-1'] == 4)].loc[:, 'MeanYieldPred'].values - df_results['NDMeanYield'].values
        df_results['D4OnsetStdYieldDiff'] = df_w[(df_w['ModeCDM'] == 5) & (df_w['ModeCDM-1'] == 4)].loc[:, 'StdYieldPred'].values - df_results['NDStdYield'].values
        #df_results['Week'] = week
        # Get TWP SHP:
        twp_shp = gpd.read_file(r"D:\PhD\YieldProject\Data\Yield\WheatYield_Township.shp")
        twp_shp = twp_shp[['TWP_ID', 'geometry']]
        twp_shp = twp_shp[twp_shp['TWP_ID'].isin(df_w['TWP_ID'])]
        twp_shp.reset_index(drop=True, inplace=True)
        twp_shp = twp_shp.sort_values(by=['TWP_ID']).reset_index(drop=True)
        twp_shp = twp_shp.merge(df_results, on = 'TWP_ID')
        # Map results
        for col in twp_shp.columns[4:]:
            stat = col.split('Onset')[1].split('Yield')[0]
            xmin, ymin, xmax, ymax = twp_shp.total_bounds
            fig, ax = plt.subplots(figsize=(9, 7))
            twp_shp.plot(column=col, cmap='YlOrRd', linewidth=0.8, ax=ax, edgecolor='0.8', legend=True,
                         scheme='naturalbreaks',
                         legend_kwds=dict(loc='best',
                                          title=f"{stat} Yield Difference (kg/ha)",
                                          frameon=False, fmt="{:.0f}")
                         )
            cx.add_basemap(ax, source=cx.providers.Stamen.TonerLite, crs=twp_shp.crs.to_string(), attribution_size=0)
            # Create spacing from data to map frame
            ax.set_xlim(xmin - 30000, xmax + 30000)
            ax.set_ylim(ymin - 20000, ymax + 20000)
            ax.set_xlabel('Longitude')
            ax.set_ylabel('Latitude')
            # Fix legend labels
            current_labels = [t.get_text() for t in ax.get_legend().get_texts()]
            new_labels = create_new_labels(current_labels, type="noround")
            update_custom_legend_labels(ax, new_labels)
            # Set custom tick positions and labels for the x-axis
            xtick_positions = [-1.4, -1.2, -1.0, -0.8, -0.6, -0.4, -0.2]
            xtick_positions = [x * 1e6 for x in xtick_positions]
            xtick_labels = ['115°W', '112°W', '109°W', '106°W', '103°W', '100°W', '97°W']
            plt.xticks(xtick_positions, xtick_labels)
            ytick_positions = [2.20, 1.96, 1.72, 1.48, 1.24, 1.0]
            ytick_positions = [x * 1e6 for x in ytick_positions]
            ytick_labels = ['59°N', '57°N', '55°N', '53°N', '51°N', '49°N']
            plt.yticks(ytick_positions, ytick_labels)
            outfile = synthMapDir + f'//Week_{week}_NDYieldDifference_{col}_{ndvi_level}.png'
            if not os.path.exists(outfile):
                plt.savefig(outfile, bbox_inches='tight', dpi=1200)
            plt.show()