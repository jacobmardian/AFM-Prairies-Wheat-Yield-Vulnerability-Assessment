import os
import sys
sys.path.append(r"D:\PhD\YieldProject\Scripts\04_Analysis")
import yieldfunctions as yf
import pandas as pd
import geopandas as gpd
import numpy as np
import matplotlib.pyplot as plt
import contextily as cx

# Set paths to GDAL in virtual env to avoid proj.db errors
os.environ['PROJ_LIB'] = r"C:\Users\jacob\miniconda3\envs\yieldprojconda\Library\share\proj"
os.environ['GDAL_DATA'] = r"C:\Users\jacob\miniconda3\envs\yieldprojconda\Library\share"
pd.set_option('display.max_columns', None)

#basemap = {'url': 'https://maps.stamen.com/toner-lite/#6/52.137/-106.649'}

# Get valid twps
predDir = r"D:\PhD\YieldProject\Output_Detrended_Ha\Predictions"
mapDir = r"D:\PhD\YieldProject\Output_Detrended_Ha\Plots\StudyArea"
df = pd.read_csv(predDir + "//AllPredictions.csv")
twp = np.unique(df.TWP_ID)

# TWP shpfile
twp_shp = gpd.read_file(r"D:\PhD\YieldProject\Data\PCPNormal\PCPNormal_TWPs_19912020.shp")
#twp_shp = twp_shp[twp_shp['TWP_ID'].isin(twp)]
twp_shp['MeanPCP'] = twp_shp['MeanPCP'] * 1000
twp_shp = twp_shp[twp_shp['MeanPCP'] > 200]
# To see AB label
twp_shp = twp_shp[~twp_shp['TWP_ID'].isin(['07310W5','07311W5','07312W5','07410W5','07411W5','00301W5','07114W6', '07214W6'])]

# Make the map
xmin, ymin, xmax, ymax = twp_shp.total_bounds
fig, ax = plt.subplots(figsize=(9, 7))
twp_shp.plot(column='MeanPCP', cmap='viridis_r', linewidth=0.1, ax=ax, edgecolor='0.8', legend=True,
             scheme='naturalbreaks',
             legend_kwds=dict(loc='best',
                              title="Precipitation (mm)",
                              frameon=False))
thicker_borders = twp_shp[twp_shp['TWP_ID'].isin(twp)]
thicker_borders.plot(linewidth=0.5, ax=ax, edgecolor='black', facecolor='none')
#cx.add_basemap(ax, source='https://api.maptiler.com/maps/bright/{z}/{x}/{y}{r}.png?key=iUKSMZtdZsw6ibSnRYDj', crs=twp_shp.crs.to_string(), attribution_size=0)
cx.add_basemap(ax, source=cx.providers.CartoDB.PositronNoLabels, crs=twp_shp.crs.to_string(), attribution_size=0)
#cx.add_basemap(ax, source=cx.providers.CartoDB.VoyagerLabelsUnder, crs=twp_shp.crs.to_string(), attribution_size=0)

# Create spacing from data to map frame
ax.set_xlim(xmin-30000, xmax+30000)
ax.set_ylim(ymin-20000, ymax+20000)
ax.set_xlabel('Longitude')
ax.set_ylabel('Latitude')
# Change labels
current_labels = [t.get_text() for t in ax.get_legend().get_texts()]
print (current_labels)
new_labels = yf.create_new_labels2(current_labels)
yf.update_custom_legend_labels(ax, new_labels)
# Fix legend labels
# current_labels = [t.get_text() for t in ax.get_legend().get_texts()]
# new_labels = yf.create_new_labels(current_labels)
# yf.update_custom_legend_labels(ax, new_labels)
# Set custom tick positions and labels for the x-axis
xtick_positions = [-1.5, -1.125, -0.75, -0.375, 0]
xtick_positions = [x * 1e6 for x in xtick_positions]
xtick_labels = ['115°W', '110°W', '105°W', '100°W', '95°W']
plt.xticks(xtick_positions, xtick_labels)
ytick_positions = [2.20, 1.88, 1.56, 1.24]
ytick_positions = [x * 1e6 for x in ytick_positions]
ytick_labels = ['58°N', '55°N', '52°N', '49°N']
plt.yticks(ytick_positions, ytick_labels)
# Inset map
# axins = zoomed_inset_axes(ax, 1, loc=1)
# axins.set_xlim(xmin-30000, xmax+30000)
# axins.set_ylim(ymin-20000, ymax+20000))
# mark_inset(ax, axins, loc1=2, loc2 = 4, fc="none", ec="0.5")
# twp_shp.plot(column='MeanPCP', cmap='viridis_r', linewidth=0.8, ax=ax, edgecolor='0.8', legend=True,
#              scheme='naturalbreaks',
#              legend_kwds=dict(loc='best',
#                               title="Precipitation (mm)",
#                               frameon=False))
# cx.add_basemap(ax, source=cx.providers.Stamen.TonerLite, crs=twp_shp.crs.to_string(), attribution_size=0)
# plt.setp(axins.get_xticklabels(), visible=False)
# plt.setp(axins.get_yticklabels(), visible=False)
plt.savefig(mapDir + '//StudyAreaMap_MeanPCP19912020.png', bbox_inches='tight', dpi=1200)
plt.show()


# TEST FOR LINEARITY:
import statsmodels.api as sm
df = df.drop_duplicates(subset=['TWP_ID', 'TotalYield'])
# Testing for each township
p_values = []
for twp_id in df['TWP_ID'].unique():
    twp_data = df[df['TWP_ID'] == twp_id].reset_index(drop=True)
    twp_agg_data = twp_data.groupby('Year')['TotalYield'].mean().reset_index()
    X = twp_agg_data['Year']
    y = twp_agg_data['TotalYield']
    #X = sm.add_constant(X)
    model = sm.OLS(y, X)
    results = model.fit()
    # Perform the Rainbow test for linearity
    rainbow_statistic, rainbow_p_value = sm.stats.linear_rainbow(results)
    print("Rainbow statistic:", rainbow_statistic)
    print("Rainbow test p-value:", rainbow_p_value)
    p_values.append(rainbow_p_value)
    # print(f"TWP_ID: {twp_id}")
    # print(results.summary())
    # print("\n")
sig_list = [item for item in p_values if item < 0.05]
print(len(sig_list))
print((len(sig_list) / len(p_values))*100)


#    slope, intercept, r_value, p_value, std_err = stats.linregress(X, y)
