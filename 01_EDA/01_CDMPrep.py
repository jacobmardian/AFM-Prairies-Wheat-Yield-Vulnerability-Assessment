# -*- coding: utf-8 -*-
"""
Created on Sun Dec 11 10:42:45 2022

@author: jacob
"""

import os
os.environ['PROJ_LIB'] = r"C:\Users\jacob\.conda\envs\yield\Library\share\proj"
os.environ['GDAL_DATA'] = r"C:\Users\jacob\.conda\envs\yield\Library\share"
import glob
import numpy as np
import fiona
import rasterio
from rasterio.warp import reproject, Resampling, calculate_default_transform
import pandas as pd
import geopandas as gpd
from geocube.api.core import make_geocube

# Define directories and create them if they don't exist
rootDir = r"D:\PhD\AAFC_Data\CDM\SHP" # downlaoded data in folders
rasDir = r"D:\PhD\AAFC_Data\CDM\Raster"
finalRasDir = r"D:\PhD\AAFC_Data\CDM\FinalRas"
finalRasDir2 = r"D:\PhD\AAFC_Data\CDM\FinalRas2"
finalRasDir3 = r"D:\PhD\AAFC_Data\CDM\FinalRas3"


# Mask raster
with rasterio.open(r"D:\PhD\AAFC_Data\Boundary\ZonalStatsZones\zones.tif") as mask_src:
    maskRas = mask_src.read()
    
def reproj_match(infile, match, outfile):
    """Reproject a file to match the shape and projection of existing raster. 
    
    Parameters
    ----------
    infile : (string) path to input file to reproject
    match : (string) path to raster with desired shape and projection 
    outfile : (string) path to output file tif
    """
    # open input
    with rasterio.open(infile) as src:
        src_transform = src.transform
        
        # open input to match
        with rasterio.open(match) as match:
            dst_crs = match.crs
            
            # calculate the output transform matrix
            dst_transform, dst_width, dst_height = calculate_default_transform(
                src.crs,     # input CRS
                dst_crs,     # output CRS
                match.width,   # input width
                match.height,  # input height 
                *match.bounds,  # unpacks input outer boundaries (left, bottom, right, top)
            )

        # set properties for output
        dst_kwargs = src.meta.copy()
        dst_kwargs.update({"crs": dst_crs,
                           "transform": dst_transform,
                           "width": dst_width,
                           "height": dst_height,
                           "nodata": 0})
        print("Coregistered to shape:", dst_height,dst_width,'\n Affine',dst_transform)
        # open output
        with rasterio.open(outfile, "w", **dst_kwargs) as dst:
            # iterate through bands and write using reproject function
            for i in range(1, src.count + 1):
                reproject(
                    source=rasterio.band(src, i),
                    destination=rasterio.band(dst, i),
                    src_transform=src.transform,
                    src_crs=src.crs,
                    dst_transform=dst_transform,
                    dst_crs=dst_crs,
                    resampling=Resampling.nearest)


# Iterate through shapefiles in subdirs:
for dirName in os.listdir(rootDir):
    files = glob.glob(os.path.join(rootDir, dirName, "*.shp"))
    prefix = os.path.basename(files[0])[0:8]
    print(prefix)
    shps = []
    for fname in files:
        if fname.endswith(".shp"):
            shps.append(gpd.read_file(fname))
    joined_shp = gpd.GeoDataFrame(pd.concat(shps))
    #shpName = os.path.join(monthDir, prefix + ".shp")
    #joined_shp.to_file(shpName)

    
    # Using GeoCube to rasterize the Vector
    raster = make_geocube(
        vector_data=joined_shp,
        measurements=["DM"],
        resolution=(-5000, 5000),
        fill = -9999
    )
    rasName = os.path.join(rasDir, prefix + ".tif")
    raster.rio.to_raster(rasName)
    
    # Mask shapefile
    with fiona.open('D:\PhD\AAFC_Data\Boundary\ZonalStatsZones\Zones.shp', 'r') as shapefile:
        cropShp = [feature["geometry"] for feature in shapefile]
        
    # Read in raster and mask to shapefile
    with rasterio.open(rasName) as ras:
        out_image, transformed = rasterio.mask.mask(ras, shapes=cropShp, 
                                                    crop=True, filled = True)
        out_profile = ras.profile.copy()
    # Add 1 to each value
    out_image[out_image == 4] = 5
    out_image[out_image == 3] = 4
    out_image[out_image == 2] = 3
    out_image[out_image == 1] = 2
    out_image[out_image == 0] = 1
    
    out_profile.update({'width': out_image.shape[2],'height': out_image.shape[1], 
                        'transform': transformed})
    outRas = os.path.join(finalRasDir, prefix + ".tif")
    with rasterio.open(outRas, "w", **out_profile) as dst:
        dst.write(out_image)
        
    # Coregister image to maskRas
    finalRas = os.path.join(finalRasDir2, prefix + ".tif")
    mask_path = r"D:\PhD\AAFC_Data\Boundary\ZonalStatsZones\zones.tif"
    reproj_match(infile = outRas, match= mask_path, outfile = finalRas)
    
    # Make the raster the same dim as maskRaster for overlays
    with rasterio.open(finalRas) as ras:
        out_image = ras.read()
        out_profile = ras.profile.copy()
    
    out_image = out_image[0]
    for i in range(maskRas.shape[0] - out_image.shape[0]):
        out_image = np.vstack([np.repeat(-9999, out_image.shape[1]), out_image])
    for i in range(maskRas.shape[1] - out_image.shape[1]):
        out_image = np.column_stack((out_image, np.repeat(-9999, out_image.shape[0])))
    
    # Add zeroes for missing data within prairies
    out_image[out_image == 0] = -9999
    out_image[(out_image == -9999) & (maskRas != 2147483647)] = 0
    
    # Add axis back
    out_image = out_image[np.newaxis, ...]
    out_profile.update({'nodata': -9999, 'dtype': rasterio.uint8})
    # Write to file
    outRas = os.path.join(finalRasDir3, prefix + ".tif")
    with rasterio.open(outRas, "w", **out_profile) as dst:
        dst.write(out_image)
    

#print(np.count_nonzero((maskRas != 2147483647)))
    
    
    
    
    
    
            
    
